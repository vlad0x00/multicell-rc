#!/usr/bin/env python3

"""
  Performs sensitivity analysis on the results of run_args script, i.e. results.csv.
"""

import csv
import sys
import os
import copy
import numpy as np
import pandas as pd
from scipy import stats, linalg
import matplotlib.pyplot as plt
import seaborn as sns
import subprocess

def partial_corr(variables):
  """
  Returns the sample linear partial correlation coefficients between pairs of variables in `variables`, controlling for the remaining variables.
  Parameters
  ----------
  variables : array-like, shape (num_samples, num_vars)
      Input matrix. Every column is an array of samples for a given variable.
  Returns
  -------
  pcorr : array-like, shape (num_vars, num_vars)
      pcorr[i, j] contains the partial correlation of variables[:, i] and variables[:, j] controlling
      for the remaining variables.

  pvals : array-like, shape (num_vars, num_vars)
      pvals[i, j] contains the p-value of variables[:, i] and variables[:, j] partial correlation.

  residues : array-like, shape (num_vars, num_vars, 2, num_samples)
      residues[i, j, k, l] contains the partial residues of variables[l, i] and variables[l, j] for variable at column i (k = 0) and column j (k = 1).
  """
  
  variables = np.asarray(variables)
  num_samples = variables.shape[0]
  num_vars = variables.shape[1]

  pcorr = np.zeros((num_vars, num_vars), dtype=np.double)
  pvals = np.zeros((num_vars, num_vars), dtype=np.double)
  residues = np.zeros((num_vars, num_vars, 2, num_samples), dtype=np.double)
  
  for i in range(num_vars):
    pcorr[i, i] = 1.0
    pvals[i, i] = 0.0
    for j in range(i + 1, num_vars):
      idx = np.ones(num_vars, dtype=np.bool)
      idx[i] = False
      idx[j] = False

      var_other_samples = variables[:, idx]
      var_i_samples = variables[:, i]
      var_j_samples = variables[:, j]

      var_other_samples_plus_intercept = np.column_stack((var_other_samples, np.ones(num_samples)))
      beta_i = linalg.lstsq(var_other_samples_plus_intercept, var_i_samples)[0]
      beta_j = linalg.lstsq(var_other_samples_plus_intercept, var_j_samples)[0]

      residue_i = var_i_samples - var_other_samples_plus_intercept.dot(beta_i)
      residue_j = var_j_samples - var_other_samples_plus_intercept.dot(beta_j)
      
      corr, p_value = stats.pearsonr(residue_i, residue_j)
      pcorr[i, j] = corr
      pcorr[j, i] = corr
      pvals[i, j] = p_value
      pvals[j, i] = p_value
      residues[i, j, 0, :] = residue_i
      residues[i, j, 1, :] = residue_j
      residues[j, i, 0, :] = residue_j
      residues[j, i, 1, :] = residue_i
      
  return pcorr, pvals, residues

results = pd.read_csv('results.csv')

del results[results.columns[0]]
columns_wo_accuracy = list(copy.deepcopy(results.columns))
assert columns_wo_accuracy[0] == 'Accuracy'
del columns_wo_accuracy[0]
results = results.groupby(columns_wo_accuracy, as_index=False).mean()
results = results[[ 'Accuracy' ] + columns_wo_accuracy]
results.reset_index(inplace=True)

# Extract only non-constant columns
results_of_interest = pd.DataFrame()
for i, column in enumerate(results.columns):
  if i == 0: continue
  if not all(x == results[column][0] for x in results[column]):
    results_of_interest[column] = results[column]

# Rank their values
ranked_results_of_interest = stats.rankdata(results_of_interest.values, axis=0)

prcc, pvals, partial_vals = partial_corr(ranked_results_of_interest)

sensitivity_results = pd.DataFrame(columns=[ "Param", "Correlation", "P-value", "Range" ])

from pandas.plotting import table 

# Make a table of results and plot the partially corrected variables
sns.set_theme(font_scale=1.2, style='white')
for i, param in enumerate(results_of_interest.columns):
  if i == 0:
    assert param == 'Accuracy'
    continue
  minval = min(results[param])
  maxval = max(results[param])
  if type(minval) == float: minval = round(minval, 2)
  if type(maxval) == float: maxval = round(maxval, 2)
  sensitivity_results.loc[i] = [ param, prcc[i, 0], pvals[i, 0], "[{}, {}]".format(minval, maxval) ]

  datapoints = pd.DataFrame({ "x" : partial_vals[i, 0, 0, :], "y" : partial_vals[i, 0, 1, :] })

  jointplot = sns.jointplot(data=datapoints, x='x', y='y', kind='hex', height=8)
  jointplot.ax_joint.set_xlabel(param)
  jointplot.ax_joint.set_ylabel("Accuracy", rotation=0, labelpad=30)
  plt.tight_layout()
  plt.savefig(param.replace(' ', '_').lower() + "_prcc.png")
sensitivity_results.sort_values(by=['Correlation'], ascending=False, inplace=True, ignore_index=True)

sensitivity_results.to_html('sensitivity_analysis.html')
subprocess.run(['wkhtmltopdf', '--page-height', '100', '--page-width', '150', '-T', '0', '-B', '0', '-L', '0', '-R', '0', 'sensitivity_analysis.html', 'sensitivity_analysis.pdf'])
subprocess.run(['magick', 'convert', '-colorspace', 'RGB', '-density', '300', 'sensitivity_analysis.pdf', '-quality', '100', '-transparent', 'white', '-crop', '1600x1000+0+0', '-trim', '+repage', '-background', 'white', '-flatten', 'sensitivity_analysis.png'])

os.remove('sensitivity_analysis.html')
os.remove('sensitivity_analysis.pdf')

table_width = int(subprocess.run([ 'identify', '-format', '%w', 'sensitivity_analysis.png' ], capture_output=True).stdout.decode())

sns.set_theme(font_scale=2.1, style='white')
fig, ax = plt.subplots()
fig.set_size_inches(table_width / 100.0, 7.0)
sns.histplot(data=results, x='Accuracy', ax=ax, bins=50, stat='probability')
ax.set_ylabel("Fraction", rotation=0, labelpad=70)
fig.tight_layout()
fig.savefig("sensitivity_analysis_accuracies.png")
plt.close(fig)

subprocess.run([ 'magick', 'convert', '-append', 'sensitivity_analysis.png', 'sensitivity_analysis_accuracies.png', 'sensitivity_analysis.png' ])
os.remove('sensitivity_analysis_accuracies.png')