#!/usr/bin/env python3

"""
  Performs sensitivity analysis on the results of run_args script, i.e. results.csv.
"""

import csv
import sys
import numpy as np
import pandas as pd
from scipy import stats, linalg
import matplotlib.pyplot as plt
import seaborn as sns

def partial_corr(C):
  """
  Returns the sample linear partial correlation coefficients between pairs of variables in C, controlling 
  for the remaining variables in C.
  Parameters
  ----------
  C : array-like, shape (n, p)
      Array with the different variables. Each column of C is taken as a variable
  Returns
  -------
  P : array-like, shape (p, p)
      P[i, j] contains the partial correlation of C[:, i] and C[:, j] controlling
      for the remaining variables in C.

  V : array-like, shape (p, p)
      V[i, j] contains the p-value of C[:, i] and C[:, j] partial correlation.

  R : array-like, shape (p, p, 2, n)
      V[i, j, k, l] contains the partial residues of C[l, i] and C[l, j] for variable
      at column i (k = 0) and column j (k = 1).
  """
  
  C = np.asarray(C)
  n = C.shape[0]
  C = np.column_stack((C, np.ones(n)))
  p = C.shape[1]

  P_corr = np.zeros((p, p), dtype=np.float)
  V = np.zeros((p, p), dtype=np.float)
  R = np.zeros((p, p, 2, n), dtype=np.float)
  
  for i in range(p):
    P_corr[i, i] = 1
    V[i, i] = 0
    for j in range(i + 1, p):
      idx = np.ones(p, dtype=np.bool)
      idx[i] = False
      idx[j] = False
      beta_i = linalg.lstsq(C[:, idx], C[:, i])[0]
      beta_j = linalg.lstsq(C[:, idx], C[:, j])[0]

      res_i = C[:, i] - C[:, idx].dot(beta_i)
      res_j = C[:, j] - C[:, idx].dot(beta_j)
      
      corr, p_value = stats.pearsonr(res_i, res_j)
      P_corr[i, j] = corr
      P_corr[j, i] = corr
      V[i, j] = p_value
      V[j, i] = p_value
      R[i, j, 0, :] = res_i
      R[i, j, 1, :] = res_j
      R[j, i, 0, :] = res_i
      R[j, i, 1, :] = res_j
      
  return P_corr, V, R

results = pd.read_csv('results.csv', sep=',')

accuracy_lt_06 = 0
accuracy_count = 0
for acc in results['Accuracy']:
  if acc < 0.6: accuracy_lt_06 += 1
  accuracy_count += 1
print("Results with <60% accuracy: {}%".format(accuracy_lt_06 / accuracy_count * 100.0))

variable_columns = []
for i, column in enumerate(results.columns):
  if i == 0: continue
  if not all(x == results[column][0] for x in results[column]):
    variable_columns.append(column)

# Extract only non-constant columns
results_of_interest = pd.DataFrame()
for column in variable_columns:
  results_of_interest[column] = results[column]

# Rank their values
ranked_results_of_interest = stats.rankdata(results_of_interest.T.values, axis=1).T

prcc, pvals, partial_vals = partial_corr(ranked_results_of_interest)

sensitivity_results = pd.DataFrame(columns=[ "Param", "Correlation", "P-value", "Range" ])

# Make a table of results and plot the partially corrected variables
for i, param in enumerate(variable_columns):
  if i == 0:
    assert param == 'Accuracy'
    continue
  minval = min(results[param])
  maxval = max(results[param])
  if type(minval) == float: minval = round(minval, 2)
  if type(maxval) == float: maxval = round(maxval, 2)
  sensitivity_results.loc[i] = [ param, prcc[i, 0], pvals[i, 0], "[{}, {}]".format(minval, maxval) ]

  datapoints = pd.DataFrame({ "x" : partial_vals[i, 0, 0, :], "y" : partial_vals[i, 0, 1, :] })
  plt.figure()
  ax = sns.scatterplot(data=datapoints, x="x", y="y", alpha=0.2)
  #ax.get_legend().remove()
  ax.set_xlabel(param)
  ax.set_ylabel("Accuracy")
  plt.tight_layout()
  plt.savefig(param + "_prcc.png")
print(sensitivity_results)