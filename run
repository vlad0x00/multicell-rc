#!/usr/bin/env python3

import os
import sys
import math
import shutil
import subprocess
import time

from utils import utils

args = utils.parse_args()

MODEL_DIR = "model/"
BIOCELLION_DIR = "biocellion/"
OUTPUT_DIR = args.output
BIOCELLION_BIN = BIOCELLION_DIR + "framework/main/biocellion.DP.SPAGENT.OPT"
BIOCELLION_OUTPUT_FILE = os.path.join(OUTPUT_DIR, "biocellion_output")
PARAMS_FILE = os.path.join(OUTPUT_DIR, "params.xml")
NV_FILE = os.path.join(OUTPUT_DIR, "nv")
VARF_FILE = os.path.join(OUTPUT_DIR, "varf")
TT_FILE = os.path.join(OUTPUT_DIR, "tt")
GENE_INITIAL_STATES_FILE = os.path.join(OUTPUT_DIR, "gene_initial_states")
DOT_FILE = os.path.join(OUTPUT_DIR, "gene_networks.dot")
NUM_GENES = 1 + args.cytokines * 2 + args.genes
NUM_CELLS = args.cells
NUM_CELL_TYPES = args.cell_types
TISSUE_DEPTH = args.tissue_depth
CONNECTIVITY = args.degree
ALPHA = args.alpha
BETA = args.beta
NUM_CYTOKINES = args.cytokines
INPUT_CONNECTIONS = math.ceil((NUM_GENES - (1 + NUM_CYTOKINES)) * args.input_fraction)
DIRICHLET_BOUNDARY = args.dirichlet_boundary
INPUT_THRESHOLD = args.input_threshold
SECRETION_LOW = args.secretion_low
SECRETION_HIGH = args.secretion_high
CYTOKINE_THRESHOLD = args.cytokine_threshold
CELL_RADIUS = args.cell_radius
IF_GRID_SPACING = args.grid_spacing
NUM_OUTPUT_GENES = math.ceil(args.genes * args.output_gene_fraction)
NUM_OUTPUT_CELLS = math.ceil(NUM_CELLS * args.output_cell_fraction)
NUM_OUTPUT_CELL_TYPES = math.ceil(NUM_CELL_TYPES * args.output_cell_type_fraction)
SIMULATION_STEPS = args.steps
DELAY = args.memory
WINDOW_SIZE = args.window_size
INPUT_SIGNAL_FILE = os.path.join(OUTPUT_DIR, "input_signal")
INPUT_SIGNAL_LENGTH = SIMULATION_STEPS + 1
FUNCTION = args.function
AUXILIARY_FILES = args.auxiliary
NEW = not args.reuse
THREADS = args.threads
WARMUP_STEPS = args.warmup_steps
Z_LAYERS = TISSUE_DEPTH
Y_LAYERS = math.ceil(math.sqrt(NUM_CELLS / Z_LAYERS))
X_LAYERS  = math.ceil(NUM_CELLS / Z_LAYERS / Y_LAYERS)
assert X_LAYERS * Y_LAYERS * Z_LAYERS >= NUM_CELLS
UNIVERSE_LENGTH = TISSUE_DEPTH + 2
UNIVERSE_WIDTH = max(X_LAYERS, Y_LAYERS) + 2

assert SIMULATION_STEPS > WARMUP_STEPS
assert CELL_RADIUS <= IF_GRID_SPACING

os.environ['OPENBLAS_NUM_THREADS'] = str(args.threads)
os.environ['OMP_NUM_THREADS'] = str(args.threads)
os.environ['MKL_NUM_THREADS'] = str(args.threads)
os.environ['BLIS_NUM_THREADS'] = str(args.threads)
os.environ['NUMEXPR_NUM_THREADS'] = str(args.threads)
os.environ['VECLIB_MAXIMUM_THREADS'] = str(args.threads)

shutil.rmtree(OUTPUT_DIR, ignore_errors=True)
os.makedirs(OUTPUT_DIR)

ADDITIONAL_PARAMS = str(NUM_GENES) + " " + str(NUM_CELLS) + " " + str(NUM_CELL_TYPES) + " " + NV_FILE + " " + VARF_FILE + " " + TT_FILE + " " + GENE_INITIAL_STATES_FILE + " " + INPUT_SIGNAL_FILE + " " + str(ALPHA) + " " + str(BETA) + " " + str(NUM_CYTOKINES) + " " + str(SECRETION_LOW) + " " + str(SECRETION_HIGH) + " " + str(CYTOKINE_THRESHOLD) + " " + str(CELL_RADIUS) + " " + str(IF_GRID_SPACING) + " " + str(DIRICHLET_BOUNDARY) + " " + str(INPUT_THRESHOLD) + " " + str(TISSUE_DEPTH)

LD_CMD = "LD_LIBRARY_PATH=$LD_LIBRARY_PATH:" + MODEL_DIR

script_dir = os.path.dirname(os.path.realpath(__file__))
if not os.path.exists(os.path.join(script_dir, MODEL_DIR, "libmodel.DP.SPAGENT.so")):
  subprocess.run([ "cd " + os.path.join(script_dir, MODEL_DIR) + "; make" ], shell=True)

if not AUXILIARY_FILES:
  if os.path.isfile(DOT_FILE):
      filename, file_extension = os.path.splitext(DOT_FILE)
      os.remove(DOT_FILE)
      os.remove(filename + ".png")
  DOT_FILE = None

if NEW:
  print("Generating initial gene network(s) state(s), functions, and input signal... ", end='', flush=True)
  t1 = time.time()
  utils.generate_gene_functions(NUM_CELL_TYPES, NUM_GENES, CONNECTIVITY, INPUT_CONNECTIONS, NUM_CYTOKINES, NV_FILE, VARF_FILE, TT_FILE, DOT_FILE)
  utils.generate_input_signal(INPUT_SIGNAL_LENGTH, INPUT_SIGNAL_FILE)
  utils.generate_gene_initial_states(NUM_GENES, NUM_CELLS, NUM_CYTOKINES, INPUT_SIGNAL_FILE, GENE_INITIAL_STATES_FILE)
  t2 = time.time()
  print("Done (in {}s)!".format(round(t2 - t1, 2)), flush=True)
utils.make_params_xml(PARAMS_FILE, OUTPUT_DIR, SIMULATION_STEPS, ADDITIONAL_PARAMS, THREADS, UNIVERSE_LENGTH, UNIVERSE_WIDTH)

print("Running Biocellion... ", end='', flush=True)
t1 = time.time()
os.system(LD_CMD + " " + BIOCELLION_BIN + " " + PARAMS_FILE + " >" + BIOCELLION_OUTPUT_FILE)
t2 = time.time()
print("Done (in {}s)!".format(round(t2 - t1, 2)), flush=True)

print("Processing output... ", end='', flush=True)
t1 = time.time()
x, y, input_signal_info = utils.process_output(INPUT_SIGNAL_FILE, BIOCELLION_OUTPUT_FILE, OUTPUT_DIR, NUM_GENES, NUM_CELLS, NUM_OUTPUT_GENES, NUM_OUTPUT_CELLS, NUM_OUTPUT_CELL_TYPES, WINDOW_SIZE, DELAY, SIMULATION_STEPS, FUNCTION, AUXILIARY_FILES, THREADS, WARMUP_STEPS, TISSUE_DEPTH)
t2 = time.time()
print("Done (in {}s)!".format(round(t2 - t1, 2)), flush=True)

correct_input = input_signal_info["correct_input"]
bad_input = input_signal_info["bad_input"]
print("Cell input signal: {} / {} ({}%) correct, {} / {} ({}%) bad".format(correct_input, NUM_CELLS, correct_input / NUM_CELLS * 100.0, bad_input, NUM_CELLS, bad_input / NUM_CELLS * 100.0))
for layer in range(TISSUE_DEPTH):
  correct_cells = input_signal_info[layer]["correct_cells"]
  bad_cells = input_signal_info[layer]["bad_cells"]
  total_cells = input_signal_info[layer]["total_cells"]
  print("Layer {}: {} / {} ({}%) correct, {} / {} ({}%) bad".format(layer, correct_cells, total_cells, correct_cells / total_cells * 100.0, bad_cells, total_cells, bad_cells / total_cells * 100.0))

print("Training LASSO... ", end='', flush=True)
t1 = time.time()
train_accuracy, test_accuracy, coeff_used, coeffs = utils.train_lasso(x, y, NUM_CELLS, NUM_OUTPUT_CELLS, NUM_OUTPUT_CELL_TYPES, NUM_OUTPUT_GENES, BIOCELLION_OUTPUT_FILE, OUTPUT_DIR, THREADS)
t2 = time.time()
print("Done (in {}s)!".format(round(t2 - t1, 2)), flush=True)

print("Training accuracy:", train_accuracy)
print("Testing accuracy:", test_accuracy)
print("Number of features used: {} / {}".format(coeff_used, coeffs))