#!/usr/bin/env python3

import os
import argparse
import pandas as pd
import numpy as np
import networkx
from sklearn.linear_model import Lasso
from sklearn.model_selection import train_test_split

import bcell_utils

parser = argparse.ArgumentParser()
parser.add_argument('-g', '--gen-initial', action='store_true', help="Generate initial boolean network state and functions. Otherwise use existing.")
args = parser.parse_args()

MODEL_DIR = "model/"
BIOCELLION_DIR = "biocellion/"
BIOCELLION_BIN = BIOCELLION_DIR + "framework/main/biocellion.DP.SPAGENT.OPT"
OUTPUT_DIR = "output/"
BIOCELLION_OUTPUT_FILE = OUTPUT_DIR + "biocellion_output"
PARAMS_FILE = MODEL_DIR + "params.xml"
NV_FILE = MODEL_DIR + "nv"
VARF_FILE = MODEL_DIR + "varf"
TT_FILE = MODEL_DIR + "tt"
BN_INITIAL_STATE_FILE = MODEL_DIR + "bn_initial_state"
DOT_FILE = MODEL_DIR + "boolean_network.dot"
NUM_GENES = 10
CONNECTIVITY = 2
INPUT_CONNECTIONS = NUM_GENES // 2
NUM_OUTPUT_GENES = NUM_GENES
NUM_CELLS = 1
MAKE_DOT = True

LASSO_ALPHA = 0.05

os.makedirs(OUTPUT_DIR, exist_ok=True)

# Simulation parameters
SIMULATION_STEPS = 50

INPUT_ARRAY_FILE = MODEL_DIR + "input_array"
INPUT_ARRAY_LENGTH = SIMULATION_STEPS
WINDOW_SIZE = 3

ADDITIONAL_PARAMS = str(NUM_GENES) + " " + str(NUM_CELLS) + " " + NV_FILE + " " + VARF_FILE + " " + TT_FILE + " " + BN_INITIAL_STATE_FILE + " " + INPUT_ARRAY_FILE

LD_CMD = "LD_LIBRARY_PATH=$LD_LIBRARY_PATH:" + MODEL_DIR

if args.gen_initial:
  if not MAKE_DOT:
    if os.path.isfile(DOT_FILE):
       os.remove(DOT_FILE)
    DOT_FILE = None
  bcell_utils.generate_gene_functions(NV_FILE, VARF_FILE, TT_FILE, DOT_FILE, NUM_GENES, CONNECTIVITY, INPUT_CONNECTIONS)
  bcell_utils.generate_bn_initial_state(BN_INITIAL_STATE_FILE, NUM_GENES)
  bcell_utils.generate_input_array(INPUT_ARRAY_FILE, INPUT_ARRAY_LENGTH)
bcell_utils.make_params_xml(PARAMS_FILE, OUTPUT_DIR, SIMULATION_STEPS, ADDITIONAL_PARAMS)

os.system(LD_CMD + " " + BIOCELLION_BIN + " " + PARAMS_FILE + " >" + BIOCELLION_OUTPUT_FILE)

with open(INPUT_ARRAY_FILE) as f:
  input_array = [ int(x) for x in f.readline().split() ]
parity = []
for i in range(WINDOW_SIZE, len(input_array) + 1):
  bitsum = 0
  for bit in input_array[(i - WINDOW_SIZE):i]:
    bitsum += bit
  if bitsum % 2 == 0: 
    parity.append(0)
  else:
    parity.append(1)

output_genes = []
for _ in range(NUM_OUTPUT_GENES):
  output_genes.append([])

with open(BIOCELLION_OUTPUT_FILE) as f:
  i = 0
  for line in f.readlines():
    if "summary" in line:
      i += 1
      if ((i + NUM_GENES - 1) / NUM_GENES < WINDOW_SIZE + 1): continue # Ignore initial state and data before full window

      tokens = line.split()[4].split(":")
      gene = int(tokens[0])
      val = int(tokens[1])
      if gene in range(NUM_GENES - 1, NUM_GENES - 1 - NUM_OUTPUT_GENES, -1):
        output_genes[NUM_GENES - 1 - gene].append(val)

assert len(output_genes[0]) == INPUT_ARRAY_LENGTH - WINDOW_SIZE + 1
for i in range(NUM_OUTPUT_GENES):
  assert len(output_genes[i]) == len(output_genes[0])

x = pd.DataFrame()
for gene in range(NUM_OUTPUT_GENES):
  x[str(gene)] = output_genes[gene]

def make_dot():
  class Node:

    def __init__(self, name):
      self.name = name

    def __str__(self):
      return self.name

    def __hash__(self):
      return self.name.__hash__()

  for index, row in x.iterrows():
    graph = networkx.DiGraph()
    for i, bit in enumerate(row):
      graph.add_node(Node(str(i)), label=bit)

    pydot_graph = networkx.drawing.nx_pydot.to_pydot(graph)
    pydot_graph.set_strict(False)
    pydot_graph.set_name("state" + str(index))
    pydot_graph.write(OUTPUT_DIR + "state" + str(index).zfill(3) + ".dot", prog='dot')
if MAKE_DOT:
  make_dot()

y = pd.DataFrame()
y['parity'] = parity

for gene in range(NUM_OUTPUT_GENES):
  len(x[str(gene)]) == len(y['parity'])

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.25)

lasso = Lasso(alpha=LASSO_ALPHA)
lasso.fit(x_train, y_train)

train_score = lasso.score(x_train, y_train)
test_score = lasso.score(x_test, y_test)
coeff_used = np.sum(lasso.coef_!=0)

print("Training score:", train_score)
print("Testing score:", test_score)
print("Number of features used:", coeff_used)