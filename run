#!/usr/bin/env python3

"""
  The main simulation driver script.
"""

import os
import sys
import math
import shutil
import subprocess
import time
from collections import defaultdict

from multicell_rc_utils import multicell_rc_params

# Parse CLI arguments
args = multicell_rc_params.parse_args()

# Setup simulation parameters based on CLI arguments (most map 1-to-1, but some have a couple of changes)
MODEL_DIR = "model/"
BIOCELLION_DIR = "biocellion/"
OUTPUT_DIR = args.output
BIOCELLION_BIN = BIOCELLION_DIR + "framework/main/biocellion.DP.SPAGENT.OPT"
BIOCELLION_OUTPUT_FILE = os.path.join(OUTPUT_DIR, "biocellion_output")
PARAMS_FILE = os.path.join(OUTPUT_DIR, "params.xml")
NV_FILE = os.path.join(OUTPUT_DIR, "nv")
VARF_FILE = os.path.join(OUTPUT_DIR, "varf")
TT_FILE = os.path.join(OUTPUT_DIR, "tt")
GENE_INITIAL_STATES_FILE = os.path.join(OUTPUT_DIR, "gene_initial_states")
DOT_FILE = os.path.join(OUTPUT_DIR, "gene_networks.dot")
NUM_GENES = 1 + args.cytokines * 2 + args.genes
NUM_CELLS = args.cells
NUM_STRAINS = args.strains
if args.tissue_depth > 0 and NUM_CELLS < args.tissue_depth:
  print("Number of cells ({}) is smaller than the required number of layers ({}). Exiting...".format(NUM_CELLS, args.tissue_depth))
  sys.exit(0)
TISSUE_DEPTH = min(NUM_CELLS, args.tissue_depth if args.tissue_depth > 0 else math.ceil(NUM_CELLS ** (1. / 3.)))
CONNECTIVITY = args.in_degree
INPUT_SIGNAL_DEPTH = args.input_signal_depth
DIRICHLET_BOUNDARY = 100_000
INPUT_THRESHOLD = -1.0 # To be numerically calculated
ALPHA_INPUT = 0.2
BETA_INPUT = 5
ALPHA_CYTOKINES = args.alpha_cytokines
BETA_CYTOKINES = args.beta_cytokines
NUM_CYTOKINES = args.cytokines
INPUT_CONNECTIONS = math.ceil((NUM_GENES - (1 + NUM_CYTOKINES)) * args.input_fraction)
SECRETION_LOW = args.secretion_low
SECRETION_HIGH = args.secretion_high
CYTOKINE_THRESHOLD = args.cytokine_threshold
CELL_RADIUS = args.cell_radius
IF_GRID_SPACING = args.voxel_length
NUM_OUTPUT_GENES = math.ceil(args.genes * args.output_gene_fraction)
NUM_OUTPUT_CELLS = math.ceil(NUM_CELLS * args.output_cell_fraction)
NUM_OUTPUT_STRAINS = math.ceil(NUM_STRAINS * args.output_strain_fraction)
OUTPUT_CELLS_RANDOM = args.output_cells_random
SIMULATION_STEPS = args.timesteps
DELAY = args.delay
WINDOW_SIZE = args.window_size
KAPPA = args.kappa
SUMMARY = args.summary
SOURCE_DIST = args.source_dist
INPUT_SIGNAL_FILE = os.path.join(OUTPUT_DIR, "input_signal")
INPUT_SIGNAL_LENGTH = SIMULATION_STEPS
FUNCTION = args.function
AUXILIARY_FILES = args.auxiliary
LASSO_WEIGHTS = args.lasso_weights
NEW = not args.reuse
THREADS = args.threads
WARMUP_STEPS = args.warmup_timesteps
Z_LAYERS = TISSUE_DEPTH
Y_LAYERS = math.ceil(math.sqrt(NUM_CELLS / Z_LAYERS))
X_LAYERS = math.ceil(NUM_CELLS / Z_LAYERS / Y_LAYERS)
assert X_LAYERS * Y_LAYERS * Z_LAYERS >= NUM_CELLS
CELLS_PER_LAYER = math.ceil(NUM_CELLS / Z_LAYERS)
UNIVERSE_LENGTH = 1 + TISSUE_DEPTH + 1
UNIVERSE_WIDTH = 1 + max(X_LAYERS, Y_LAYERS) + 1
CYTOKINE_NORMALIZATION_NUM_GENES = 3
CYTOKINE_NORMALIZATION_UNIVERSE_SIZE = 20
CYTOKINE_NORMALIZATION_SIMULATION_STEPS = 2
CYTOKINE_NORMALIZATION_INPUT_SIGNAL_LENGTH = CYTOKINE_NORMALIZATION_SIMULATION_STEPS + 1
CYTOKINE_NORMALIZATION = -1.0 # To be numerically calculated

assert SIMULATION_STEPS > WARMUP_STEPS
assert CELL_RADIUS <= IF_GRID_SPACING

'''
  These must be setup before importing numpy in order to work.
  Scipy LassoCV does not always respect the njobs (threads) parameter,
  hence the need for the environment variables.
'''
os.environ['OPENBLAS_NUM_THREADS'] = str(args.threads)
os.environ['OMP_NUM_THREADS'] = str(args.threads)
os.environ['MKL_NUM_THREADS'] = str(args.threads)
os.environ['BLIS_NUM_THREADS'] = str(args.threads)
os.environ['NUMEXPR_NUM_THREADS'] = str(args.threads)
os.environ['VECLIB_MAXIMUM_THREADS'] = str(args.threads)

# Include Biocellion .so files before running
LD_CMD = "LD_LIBRARY_PATH=$LD_LIBRARY_PATH:" + MODEL_DIR

# Build the Biocellion model if it hasn't been built. 
script_dir = os.path.dirname(os.path.realpath(__file__))
if not os.path.exists(os.path.join(script_dir, MODEL_DIR, "libmodel.DP.SPAGENT.so")):
  subprocess.run([ "cd " + os.path.join(script_dir, MODEL_DIR) + "; make" ], shell=True)

# Remove generated auxilliary files from previous simulation, if any
if not AUXILIARY_FILES:
  if os.path.isfile(DOT_FILE):
      filename, file_extension = os.path.splitext(DOT_FILE)
      os.remove(DOT_FILE)
      os.remove(filename + ".png")
  DOT_FILE = None

# These have to be imported after the export of the environment vars, as they import numpy
from multicell_rc_utils import multicell_rc_gen
from multicell_rc_utils import multicell_rc_train

# Run Biocellion to numerically normalize secretion level and calculate input signal threshold
print("Running numerical analysis for parameters... ", end='', flush=True)
t1 = time.time()

# Arguments passed to Biocellion directly
CYTOKINE_NORMALIZATION_ADDITIONAL_PARAMS = str(CYTOKINE_NORMALIZATION_NUM_GENES) + " 1 1 " + NV_FILE + " " + VARF_FILE + " " + TT_FILE + " " + GENE_INITIAL_STATES_FILE + " " + INPUT_SIGNAL_FILE + " " + str(ALPHA_CYTOKINES) + " " + str(BETA_CYTOKINES) + " 1 " + str(SECRETION_LOW) + " " + str(SECRETION_HIGH) + " " + str(CYTOKINE_THRESHOLD) + " " + str(CELL_RADIUS) + " " + str(IF_GRID_SPACING) + " " + str(DIRICHLET_BOUNDARY) + " " + str(INPUT_THRESHOLD) + " " + str(ALPHA_INPUT) + " " + str(BETA_INPUT) + " 1 1 1 " + str(KAPPA) + " " + str(True) + " " + str(CYTOKINE_NORMALIZATION_UNIVERSE_SIZE // 2) + " 1.0 " + str(True) + " " + str(CELLS_PER_LAYER)

# Remove the output dir of a previous run, if any, and create a new one
shutil.rmtree(OUTPUT_DIR, ignore_errors=True)
os.makedirs(OUTPUT_DIR)

multicell_rc_gen.generate_cytokine_normalization_files(CYTOKINE_NORMALIZATION_NUM_GENES, NV_FILE, VARF_FILE, TT_FILE, INPUT_SIGNAL_FILE, CYTOKINE_NORMALIZATION_INPUT_SIGNAL_LENGTH, GENE_INITIAL_STATES_FILE)
multicell_rc_gen.make_params_xml(PARAMS_FILE, OUTPUT_DIR, CYTOKINE_NORMALIZATION_SIMULATION_STEPS, CYTOKINE_NORMALIZATION_ADDITIONAL_PARAMS, THREADS, CYTOKINE_NORMALIZATION_UNIVERSE_SIZE, CYTOKINE_NORMALIZATION_UNIVERSE_SIZE)

os.system(LD_CMD + " " + BIOCELLION_BIN + " " + PARAMS_FILE + " >" + BIOCELLION_OUTPUT_FILE)
t2 = time.time()
print("Done (in {}s)!".format(round(t2 - t1, 2)), flush=True)

def nested_dict(n, type):
    if n == 1:
        return defaultdict(type)
    else:
        return defaultdict(lambda: nested_dict(n - 1, type))
input_vals = nested_dict(3, float)

with open(BIOCELLION_OUTPUT_FILE, 'r') as f:
  counter = 0
  for line in f:
    if 'cytokine0_max' in line:
      counter += 1
      if counter == 2: CYTOKINE_NORMALIZATION = float(line.split(':')[1])
    elif 'Input signal val' in line:
      tokens = line.split()
      x, y, z = [ int(coord) for coord in tokens[3][1:-1].split(',') ]
      val = float(tokens[5])
      input_vals[x][y][z] = val

for x in input_vals.keys():
  assert len(input_vals.keys()) == len(input_vals[x].keys())
  for y in input_vals[x].keys():
    assert len(input_vals[x].keys()) == len(input_vals[x][y].keys())

for z in input_vals[0][0].keys():
  current_input_val = input_vals[0][0][z]
  for x in input_vals.keys():
    for y in input_vals[x].keys():
      assert current_input_val == input_vals[x][y][z]

for x in input_vals.keys():
  for y in input_vals[x].keys():
    input_vals[x][y][-1] = DIRICHLET_BOUNDARY
    input_vals[x][y][len(input_vals.keys())] = 0

INPUT_THRESHOLD = (input_vals[0][0][SOURCE_DIST - 1 + INPUT_SIGNAL_DEPTH] + input_vals[0][0][SOURCE_DIST - 1 + INPUT_SIGNAL_DEPTH + 1]) / 2
assert INPUT_THRESHOLD > 0.0
assert CYTOKINE_NORMALIZATION > 0.0

print("Tissue shape: {} x {} x {}".format(X_LAYERS, Y_LAYERS, Z_LAYERS))

# Arguments passed to Biocellion directly
ADDITIONAL_PARAMS = str(NUM_GENES) + " " + str(NUM_CELLS) + " " + str(NUM_STRAINS) + " " + NV_FILE + " " + VARF_FILE + " " + TT_FILE + " " + GENE_INITIAL_STATES_FILE + " " + INPUT_SIGNAL_FILE + " " + str(ALPHA_CYTOKINES) + " " + str(BETA_CYTOKINES) + " " + str(NUM_CYTOKINES) + " " + str(SECRETION_LOW) + " " + str(SECRETION_HIGH) + " " + str(CYTOKINE_THRESHOLD) + " " + str(CELL_RADIUS) + " " + str(IF_GRID_SPACING) + " " + str(DIRICHLET_BOUNDARY) + " " + str(INPUT_THRESHOLD) + " " + str(ALPHA_INPUT) + " " + str(BETA_INPUT) + " " + str(Z_LAYERS) + " " + str(Y_LAYERS) + " " + str(X_LAYERS) + " " + str(KAPPA) + " " + str(SUMMARY) + " " + str(SOURCE_DIST) + " " + str(CYTOKINE_NORMALIZATION) + " " + str(False) + " " + str(CELLS_PER_LAYER)

# Remove the output dir of a previous run, if any, and create a new one
shutil.rmtree(OUTPUT_DIR, ignore_errors=True)
os.makedirs(OUTPUT_DIR)

# Should new input signal, boolean networks, and initial states be generated?
if NEW:
  print("Generating initial gene network(s) state(s), functions, and input signal... ", end='', flush=True)
  t1 = time.time()
  multicell_rc_gen.generate_gene_functions(NUM_STRAINS, NUM_GENES, CONNECTIVITY, INPUT_CONNECTIONS, NUM_CYTOKINES, NV_FILE, VARF_FILE, TT_FILE, DOT_FILE)
  multicell_rc_gen.generate_input_signal(INPUT_SIGNAL_LENGTH, INPUT_SIGNAL_FILE)
  multicell_rc_gen.generate_gene_initial_states(NUM_GENES, NUM_CELLS, NUM_CYTOKINES, INPUT_SIGNAL_FILE, GENE_INITIAL_STATES_FILE)
  t2 = time.time()
  print("Done (in {}s)!".format(round(t2 - t1, 2)), flush=True)
# Generate the Biocellion XML
multicell_rc_gen.make_params_xml(PARAMS_FILE, OUTPUT_DIR, SIMULATION_STEPS, ADDITIONAL_PARAMS, THREADS, UNIVERSE_LENGTH, UNIVERSE_WIDTH)

# Run and time the Biocellion executable
print("Running Biocellion... ", end='', flush=True)
t1 = time.time()
os.system(LD_CMD + " " + BIOCELLION_BIN + " " + PARAMS_FILE + " >" + BIOCELLION_OUTPUT_FILE)
t2 = time.time()
print("Done (in {}s)!".format(round(t2 - t1, 2)), flush=True)

# Load gene states from files of all simulation steps
print("Processing output... ", end='', flush=True)
t1 = time.time()
x, y, input_signal_info, output_cells = multicell_rc_train.process_output(INPUT_SIGNAL_FILE, BIOCELLION_OUTPUT_FILE, OUTPUT_DIR, NUM_GENES, NUM_CELLS, NUM_OUTPUT_GENES, NUM_OUTPUT_CELLS, NUM_OUTPUT_STRAINS, OUTPUT_CELLS_RANDOM, WINDOW_SIZE, DELAY, SIMULATION_STEPS, FUNCTION, AUXILIARY_FILES, THREADS, WARMUP_STEPS, Z_LAYERS, Y_LAYERS, X_LAYERS, INPUT_SIGNAL_DEPTH, CELLS_PER_LAYER)
t2 = time.time()
print("Done (in {}s)!".format(round(t2 - t1, 2)), flush=True)

# Print the number of cells that have received the input signal, fully or partially
correct_input = input_signal_info["correct_input"]
bad_input = input_signal_info["bad_input"]
print("Cell input signal: {} / {} ({:.2f}%) correct, {} / {} ({:.2f}%) bad".format(correct_input, NUM_CELLS, correct_input / NUM_CELLS * 100.0, bad_input, NUM_CELLS, bad_input / NUM_CELLS * 100.0))
if correct_input == 0: print("WARNING: no cell has received input signal fully or at all.", file=sys.stderr)
for layer in range(Z_LAYERS):
  correct_cells = input_signal_info[layer]["correct_cells"]
  bad_cells = input_signal_info[layer]["bad_cells"]
  total_cells = input_signal_info[layer]["total_cells"]
  print("Layer {}: {} / {} ({:.2f}%) correct, {} / {} ({:.2f}%) bad".format(layer, correct_cells, total_cells, correct_cells / total_cells * 100.0, bad_cells, total_cells, bad_cells / total_cells * 100.0))

# Train Lasso on gene states
print("Training LASSO... ", end='', flush=True)
t1 = time.time()
train_accuracy, test_accuracy, cell_feature_data, strain_feature_data, max_features, cell_weights = multicell_rc_train.train_lasso(x, y, NUM_CELLS, NUM_OUTPUT_CELLS, NUM_OUTPUT_STRAINS, NUM_OUTPUT_GENES, BIOCELLION_OUTPUT_FILE, OUTPUT_DIR, THREADS, output_cells, X_LAYERS, Y_LAYERS, Z_LAYERS, CELLS_PER_LAYER)
t2 = time.time()
print("Done (in {}s)!".format(round(t2 - t1, 2)), flush=True)

# Print the statistics
print("Training accuracy:", train_accuracy)
print("Testing accuracy:", test_accuracy)
features_used = int(cell_feature_data['features'].sum())
if max_features > 0:
  features_used_percent = features_used / max_features * 100.0
else:
  features_used_percent = 0.0
print("LASSO features used: {} / {} ({:.2f}%)".format(features_used, max_features, features_used_percent))
for layer in range(Z_LAYERS):
  layer_cells = cell_feature_data[cell_feature_data['layer'] == layer]
  layer_features = int(layer_cells['features'].sum())
  if features_used > 0:
    layer_features_percent = layer_features / features_used * 100.0
  else:
    layer_features_percent = 0.0
  print("Layer {}: {} / {} ({:.2f}%)".format(layer, layer_features, features_used, layer_features_percent))

if LASSO_WEIGHTS:
  output_cells = list(cell_weights.keys())
  print("Output cells: {}".format(' '.join([ str(c) for c in output_cells ])))
  print("Output cell weights (cells with all 0 weights omitted):")
  for cell in output_cells:
    weights = cell_weights[cell]
    if any([ w != 0 for w in weights ]):
      print("{}: {}".format(cell, ' '.join([ str(w) for w in weights ])))