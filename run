#!/usr/bin/env python3

import os
import sys
import argparse
import pandas as pd
import numpy as np
import networkx
import math
from sklearn.linear_model import Lasso, LassoCV
from sklearn.model_selection import train_test_split

import bcell_utils

parser = argparse.ArgumentParser()
parser.add_argument('-n', '--nodes', type=int, default=50, help="Number of nodes in boolean network(s).")
parser.add_argument('-c', '--cells', type=int, default=1, help="Number of cells in the simulation.")
parser.add_argument('-d', '--degree', type=int, default=2, help="Average node in-degree of boolean network(s).")
parser.add_argument('-i', '--input-fraction', type=float, default=0.5, help="Fraction of nodes connected to the input signal.")
parser.add_argument('-s', '--steps', type=int, default=150, help="Number of simulation steps.")
parser.add_argument('-t', '--time-delay', type=int, default=0, help="Step delay between a boolean network update from an input signal and output layer prediction.")
parser.add_argument('-w', '--window-size', type=int, default=3, help="Window size of predicted functions.")
parser.add_argument('-g', '--generate', action='store_true', help="Generate initial boolean network state, functions, and input array. Otherwise use existing.")
parser.add_argument('-z', '--visualize', action='store_true', help="Generate a dot file of the boolean network model and every state of the simulation for visualization and debugging.")
args = parser.parse_args()

MODEL_DIR = "model/"
BIOCELLION_DIR = "biocellion/"
BIOCELLION_BIN = BIOCELLION_DIR + "framework/main/biocellion.DP.SPAGENT.OPT"
OUTPUT_DIR = "output/"
BIOCELLION_OUTPUT_FILE = OUTPUT_DIR + "biocellion_output"
PARAMS_FILE = MODEL_DIR + "params.xml"
NV_FILE = MODEL_DIR + "nv"
VARF_FILE = MODEL_DIR + "varf"
TT_FILE = MODEL_DIR + "tt"
BN_INITIAL_STATE_FILE = MODEL_DIR + "bn_initial_state"
DOT_FILE = MODEL_DIR + "boolean_network.dot"
NUM_GENES = args.nodes
CONNECTIVITY = args.degree
INPUT_CONNECTIONS = math.ceil(NUM_GENES * args.input_fraction)
NUM_OUTPUT_GENES = NUM_GENES
NUM_CELLS = args.cells
DELAY = args.time_delay
SIMULATION_STEPS = args.steps
INPUT_ARRAY_FILE = MODEL_DIR + "input_array"
INPUT_ARRAY_LENGTH = SIMULATION_STEPS + 1
WINDOW_SIZE = args.window_size
LASSO_ALPHA = 0.005

os.makedirs(OUTPUT_DIR, exist_ok=True)

ADDITIONAL_PARAMS = str(NUM_GENES) + " " + str(NUM_CELLS) + " " + NV_FILE + " " + VARF_FILE + " " + TT_FILE + " " + BN_INITIAL_STATE_FILE + " " + INPUT_ARRAY_FILE

LD_CMD = "LD_LIBRARY_PATH=$LD_LIBRARY_PATH:" + MODEL_DIR

if args.generate:
  print("Generating initial boolean network state, functions, and input array... ", end='', flush=True)
  if not args.visualize:
    if os.path.isfile(DOT_FILE):
       os.remove(DOT_FILE)
    DOT_FILE = None
  bcell_utils.generate_gene_functions(NV_FILE, VARF_FILE, TT_FILE, DOT_FILE, NUM_GENES, CONNECTIVITY, INPUT_CONNECTIONS)
  bcell_utils.generate_input_array(INPUT_ARRAY_FILE, INPUT_ARRAY_LENGTH)
  bcell_utils.generate_bn_initial_state(BN_INITIAL_STATE_FILE, NUM_GENES, INPUT_ARRAY_FILE)
  print("Done!", flush=True)
bcell_utils.make_params_xml(PARAMS_FILE, OUTPUT_DIR, SIMULATION_STEPS, ADDITIONAL_PARAMS)

print("Running Biocellion... ", end='', flush=True)
os.system(LD_CMD + " " + BIOCELLION_BIN + " " + PARAMS_FILE + " >" + BIOCELLION_OUTPUT_FILE)
print("Done!", flush=True)

print("Training LASSO... ", end='', flush=True)
with open(INPUT_ARRAY_FILE) as f:
  input_array = [ int(x) for x in f.readline().split() ]

states = []
with open(BIOCELLION_OUTPUT_FILE) as f:
  i = 0
  s = -1
  for line in f.readlines():
    if "interface grid summary" in line:
      i += 1

      if "Timestep" in line:
        s += 1
        states.append([])

      if "Gene" in line:
        tokens = line.split()[4].split(":")
        gene = int(tokens[0])
        val = int(tokens[1])
        if gene in range(NUM_GENES - 1, NUM_GENES - 1 - NUM_OUTPUT_GENES, -1):
          states[s].append(val)

states = states[WINDOW_SIZE:]
for state in states:
  assert len(state) == NUM_OUTPUT_GENES

parity = []
for i in range(WINDOW_SIZE, len(input_array)):
  bitsum = 0
  for bit in input_array[(i - WINDOW_SIZE):i]:
    bitsum += bit
  if bitsum % 2 == 0: 
    parity.append(0)
  else:
    parity.append(1)
assert len(input_array) == len(parity) + WINDOW_SIZE

median = []
for i in range(WINDOW_SIZE, len(input_array)):
  bitsum = 0
  for bit in input_array[(i - WINDOW_SIZE):i]:
    bitsum += bit
  if bitsum > WINDOW_SIZE // 2:
    median.append(1)
  else:
    median.append(0)
assert len(input_array) == len(median) + WINDOW_SIZE

x = states
y = median

if DELAY > 0:
  x = x[DELAY:]
  y = y[:-DELAY]

def make_dot():
  class Node:

    def __init__(self, name):
      self.name = name

    def __str__(self):
      return self.name

    def __hash__(self):
      return self.name.__hash__()

  for index, row in x.iterrows():
    graph = networkx.DiGraph()
    for i, bit in enumerate(row):
      graph.add_node(Node(str(i)), label=bit)

    pydot_graph = networkx.drawing.nx_pydot.to_pydot(graph)
    pydot_graph.set_strict(False)
    pydot_graph.set_name("state" + str(index))
    pydot_graph.write(OUTPUT_DIR + "state" + str(index).zfill(3) + ".dot", prog='dot')
if args.visualize:
  make_dot()
else:
  for filename in os.listdir(OUTPUT_DIR):
    if filename.startswith("state"):
      os.remove(OUTPUT_DIR + filename)

assert len(x) == len(y)
for s in x:
  assert len(s) == NUM_GENES

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.25)

lasso = LassoCV(max_iter=10000)
#lasso = Lasso(alpha=LASSO_ALPHA)
lasso.fit(x_train, y_train)

train_score = lasso.score(x_train, y_train)
test_score = lasso.score(x_test, y_test)
coeff_used = np.sum(lasso.coef_!=0)

print("Done!", flush=True)

print("Training score:", train_score)
print("Testing score:", test_score)
print("Number of features used:", coeff_used)