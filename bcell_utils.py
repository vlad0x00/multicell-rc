import numpy as np
import random
import xml.etree.ElementTree as ET
from xml.etree.ElementTree import Element, SubElement, Comment
from xml.dom import minidom
import csv
import networkx

class Node:

  def __init__(self, name):
    self.name = name

  def __str__(self):
    return self.name

  def __hash__(self):
    return self.name.__hash__()

def make_dot(nv, varf, varf_offsets, dot_file):
  graph = networkx.DiGraph()

  nodes = []
  for i in range(len(nv)):
    node = Node(str(i))
    nodes.append(node)
    graph.add_node(node)

  for i in range(len(nv)):
    for v in varf[varf_offsets[i]:(varf_offsets[i] + nv[i])]:
      graph.add_edge(nodes[i], nodes[v])

  pydot_graph = networkx.drawing.nx_pydot.to_pydot(graph)
  pydot_graph.set_strict(False)
  pydot_graph.set_name("boolean_network")
  pydot_graph.write(dot_file, prog='dot')

def generate_gene_functions(nv_file, varf_file, tt_file, dot_file, num_genes, connectivity, input_connections):
  assert input_connections <= num_genes

  nv = np.ones(num_genes, dtype=np.int32) * connectivity
  nv[0] = 0
  for i in range(1, input_connections + 1):
    nv[i] += 1

  current_varf_offset = 0
  varf_offsets = []
  for v in nv:
    varf_offsets.append(current_varf_offset)
    current_varf_offset += v

  current_tt_offset = 0
  tt_offsets = []
  for v in nv:
    tt_offsets.append(current_tt_offset)
    if v > 0:
      current_tt_offset += 2 ** v

  available_nodes = [ x for x in range(1, num_genes) ]
  connection_pool = []
  for _ in range(connectivity):
    connection_pool += available_nodes

  def take_from_pool(pool, num, exclude):
    nodes = []
    for _ in range(num):
      while True:
        idx = random.randint(0, len(pool) - 1)
        node = pool[idx]
        if ((not node in exclude) and (not node in nodes)) or sorted(pool) == sorted(exclude):
          nodes.append(node)
          pool.pop(idx)
          break
    return nodes

  varf = np.ones(current_varf_offset, dtype=np.int32) * -1
  for i in range(len(varf_offsets) - 1):
    v = varf_offsets[i + 1] - varf_offsets[i]
    if v > 0:
      varf[varf_offsets[i]:(varf_offsets[i] + connectivity)] = take_from_pool(connection_pool, connectivity, [i])
  varf[varf_offsets[-1]:current_varf_offset] = take_from_pool(connection_pool, connectivity, [(len(varf_offsets) - 1)])

  for i in range(1, input_connections + 1):
    if i + 1 < len(varf_offsets):
      varf[varf_offsets[i + 1] - 1] = 0
    else:
      varf[current_varf_offset - 1] = 0

  assert len(connection_pool) == 0

  tt = np.random.randint(2, size=current_tt_offset)

  with open(nv_file, 'w') as f:
    f.write(' '.join([str(x) for x in nv]))

  with open(varf_file, 'w') as f:
    f.write(' '.join([str(x) for x in varf]))

  with open(tt_file, 'w') as f:
    f.write(' '.join([str(x) for x in tt]))

  if dot_file != None:
    make_dot(nv, varf, varf_offsets, dot_file)

def generate_bn_initial_state(state_file, num_genes):
  state = np.random.randint(2, size=num_genes)
  with open(state_file, 'w') as f:
    f.write(' '.join([str(x) for x in state]))

def generate_input_array(array_file, array_len):
  arr = np.random.randint(2, size=array_len)
  with open(array_file, 'w') as f:
    f.write(' '.join([str(x) for x in arr]))

def prettify(elem):
  """Return a pretty-printed XML string for the Element.
  """
  rough_string = ET.tostring(elem, 'utf-8')
  reparsed = minidom.parseString(rough_string)
  return reparsed.toprettyxml(indent="  ")

def make_params_xml(xml_path, output_dir, simulation_steps, additional_params):
  xml_file = open(xml_path, 'w')

  # Biocellion required parameters
  bcell_num_baseline = simulation_steps
  bcell_nx = '16'
  bcell_ny = '16'
  bcell_nz = '16'
  bcell_partition_size = 16
  bcell_path = output_dir
  bcell_interval = 1
  bcell_start_x = 0
  bcell_start_y = 0
  bcell_start_z = 0
  bcell_size_x = 16
  bcell_size_y = 16
  bcell_size_z = 16

  # Biocellion optional parameteres
  bcell_input_param = additional_params
  bcell_verbosity = 0 # [0-5]

  bcell_num_threads = 6
  bcell_num_node_groups = 1
  bcell_num_nodes_per_group = 1
  bcell_num_sockets_per_node = 1
  bcell_max_load_imbalance = 1.2

  bcell_super_x = 64
  bcell_super_y = 64
  bcell_super_z = 64

  bcell_summary = 1
  bcell_load_balance = 0
  bcell_regridding = 1000
  bcell_checkpoint = 0

  bcell_refine_ratio = 2
  bcell_fill_ratio = 0.5

  #  Write xml for Biocellion
  top = Element('biocellion')

  comment = Comment('Input parameters for Biocellion, generated by Python parser.')
  top.append(comment)

  # Printing required parameters
  xml_required = SubElement(top, 'required')
  xml_required.append(Comment('Required Parameters for biocellion.'))

  xml_time_step = SubElement(xml_required, 'time_step')
  xml_time_step.set('num_baseline', str(bcell_num_baseline))

  xml_domain = SubElement(xml_required, 'domain')
  xml_domain.set('x', str(bcell_nx))
  xml_domain.set('y', str(bcell_ny))
  xml_domain.set('z', str(bcell_nz))

  xml_init_data = SubElement(xml_required, 'init_data')
  xml_init_data.set('partition_size', str(bcell_partition_size))
  xml_init_data.set('src', 'code') 

  xml_output = SubElement(xml_required, 'output ')
  xml_output.set('path', bcell_path)
  xml_output.set('interval', str(bcell_interval))
  xml_output.set('particle', 'pvtp')
  xml_output.set('grid', 'vthb')
  xml_output.set('start_x', str(bcell_start_x))
  xml_output.set('start_y', str(bcell_start_y))
  xml_output.set('start_z', str(bcell_start_z))
  xml_output.set('size_x', str(bcell_size_x))
  xml_output.set('size_y', str(bcell_size_y))
  xml_output.set('size_z', str(bcell_size_z))

  # Printing Required parameterss
  xml_optional = SubElement(top, 'optional')
  xml_optional.append(Comment('Optional parameters for biocellion.'))

  xml_bioparm_model = SubElement(xml_optional, 'model')
  xml_bioparm_model.set('param', bcell_input_param)

  xml_bioparm_stdout = SubElement(xml_optional, 'stdout')
  xml_bioparm_stdout.set('verbosity', str(bcell_verbosity))

  xml_bioparm_system = SubElement(xml_optional, 'system')
  xml_bioparm_system.set('num_node_groups', str(bcell_num_node_groups))
  xml_bioparm_system.set('num_nodes_per_group', str(bcell_num_nodes_per_group))
  xml_bioparm_system.set('num_sockets_per_node', str(bcell_num_sockets_per_node))
  xml_bioparm_system.set('max_load_imbalance', str(bcell_max_load_imbalance))#
  xml_bioparm_system.set('num_threads', str(bcell_num_threads))

  xml_bioparm_super_partition = SubElement(xml_optional, 'super_partition')
  xml_bioparm_super_partition.set('x', str(bcell_super_x))
  xml_bioparm_super_partition.set('y', str(bcell_super_y))
  xml_bioparm_super_partition.set('z', str(bcell_super_z))

  xml_interval = SubElement(xml_optional, 'interval')
  xml_interval.set('summary', str(bcell_summary))
  xml_interval.set('load_balance', str(bcell_load_balance))
  xml_interval.set('regridding', str(bcell_regridding))
  xml_interval.set('checkpoint', str(bcell_checkpoint))

  xml_amr = SubElement(xml_optional, 'amr')
  xml_amr.set('refine_ratio', str(bcell_refine_ratio))
  xml_amr.set('fill_ratio', str(bcell_fill_ratio))

  xml_file.write(prettify(top))